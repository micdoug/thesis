\chapter{Groups NET Distributed Implementation}
\label{ch:GroupsNet}

In D2D networks communication is established when a contact occurs, and the contacts are driven by human mobility.
Therefore understanding human mobility and how people interact is a fundamental requirement to create good solutions in this scenario.
Recent works have shown that the best solutions for D2D communication are those based on social context, mainly those that explore how
people interact in groups or communities. In this chapter we propose a distributed implementation of Groups-NET, a forwarding algorithm
based on group encounters \cite{nunes2016leveraging}. We propose an algorithm for group detection and tracking in a distributed environment
and used this to implement Groups-NET. Through experiments with a real mobility trace containing 115 nodes we show that the solution achieves
a good delivery ratio with an expressive lower network overhead when compared with the state-of-art BubbleRap algorithm.

<Write down the chapter structure when finished>
% This chapter is organized as follows. The section \ref{sec:groupsNet} details the original Groups NET implementation as is proposed in \cite{nunes2016leveraging}.
% The section \ref{sec:distributedGroupsNET} details the proposed distributed implementation inspired by the original Groups NET. This sectio is divided in two parts: in
% \ref{subsec:subsec:groupDetection} the grouping detection algorithm is detailed and in \ref{subsec:forwardingDistGroupsNET} the forwarding decision is also detailed.
% In section \ref{sec:GNExperiments}

\section{The Groups NET Algorithm}
\label{sec:groupsNet}

Groups-NET is a multi hop and multi copy forwarding algorithm for D2D networks that explores people group meetings to propagate content.
A group is defined as a set of people that are together in a place due to a common goal. For example, people working in the same company or students attending the same class.
The algorithm is based on the idea that group encounters show some regularity along the time, because in general people have regular schedules and routines. Therefore we
can explore group encounters to forward messages. In their previous work, \citet{groupMobility} proposed an algorithm for group detection and tracking, in which
detected groups show encounters regularity along the time, mainly on daily and weekly basis. This algorithm operates on contact traces.

First, the contact trace is split considering time windows of a predefined size. Contacts in each time window are used
to create contact graphs, in which vertices denotes devices and edges denotes contacts in that time window. After this
a sequence of graph contacts along the time is created, representing people contacts along the time. For each of these graphs
the clustering algorithm Clique Percolation \cite{derenyi2005clique} is executed, to find clusters based on the contacts of a time interval.
A cluster in a contact graph represents a group encounter in a that time interval. In order to find groups that have encounters in different time windows
the authors introduced the \textit{Group Correlation Coefficient} metric, which measures the similarity of two group captured in distinct contact graphs returning a value
between 0 and 1. It is defined as the number of intersection members of the two groups divided by the number of members of the union of the groups.

<Finish to explain how the forwarding decision is defined based on group encounters>

<Discuss the centralized nature of this solution and talk about the major challenges to develop>

<The following sections were not revised yet, I put just some notes to guide me>

\section{Distributed Groups NET}
\label{sec:distributedGroupsNET}

In this section we propose a distributed implementation of Groups NET forwarding algorithm. The solution is
comprised of two stages: The first stage is group detection, in which nodes use neighborhood discovery to
infer social group meeting using a local algorithm. The second stage is message forwarding, in which nodes
use the generated group data to decide when to forward a message or not. The following sections describe in
details the two stages.

\subsection{Grouping Detection and Tracking}
\label{subsec:groupDetection}

The mobile group detection algorithm proposed here is derived from the ideas presented in \cite{groupMobility}.
A group is defined as a set of people that get in contact on a given point of space and time. The authors show that
group encounters have some level of regularity along the time (mainly at daily and weekly basis). This property can be used by forwarding algorithms.

In the original proposal the authors use a approach to detect groups based on global network knowledge. They basically
build a contact graph considering a predefined time interval, and for each graph is used the Clique Percolation community
detection algorithm. Each community detected by the algorithm is considered a group meeting in that time window. Then
a metric called \textit{Group Correlation Coefficient} is used to detect instances of the same group across multiple time
windows.

With this approach the authors show that groups usually have regular encounters along the time (specially in daily and weekly basis).
But they also discuss that the detection approach is unfeasible for a distributed environment, because it assumes a global network
knowledge. However, authors also discuss that implementing a distributed solution for this should be a simple task, because in the local
scope nodes can use neighborhood discover strategies and process regular neighbors encounters to decide their group encounters.

In this work we expanded this idea to build a distributed solution for group detection.It is composed of four processes
that are executed concurrently by each node using basically neighborhood inspection and some basic additional parameters. In the following sections each process is explained.

\subsubsection{Device's Local Group Detection}

This process is responsible for processing nodes' local contacts and decide when a group meeting happens.
The algorithm is very simple. Each node keeps two lists of devices. The first is the \textit{friends} list (lets call it FL)
that keeps track of current nodes considered as friends, i.e, members of a group that have a recent encounter.
The second list is the \textit{strangers} list (lets call it SL), that keeps track of recent nodes' contacts that are not yet
considered as friends. Each entry in these lists have a contact counter that keeps track of consecutive
contacts with that node, and also have a inactive counter that keeps track of consecutive periods of time
without contact with that node.

The node inspects its neighborhood at each predefined \textit{time interval} and based on current neighbors
it updates the friends and strangers list. This update is based on two predefined parameters: the \textit{friend threshold}
and \textit{inactive threshold}. Lets call these parameters as FT and IT respectively. Based on these parameters the following
steps are executed:

\begin{itemize}
	\item At each time interval a node collects its current neighbors (lets call it CN).
	\item The first step is to update the counters of friends list. For each current neighbor that is present in the friends
	list, we increase the contact counter and reset the inactive counter. For each node present in the friends list that is
	not a current neighbor we reset the contact counter and increase the inactive counter.
	\item The second step is to update the strangers list. For each current neighbor that is present in the strangers list
	we reset the inactive counter and increase the contact counter. If the contact counter reaches the friend threshold
	the node is promoted to friends list. For each node that is present in strangers list but is not a current neighbor
	we reset the contact counter and increase the inactive counter. If the inactive counter reaches the inactive threshold
	the node is removed from the strangers list. Nodes that are current neighbors and are not present in both friends and strangers
	list are added in the strangers list with contact counter equals 1.
	\item As a final step, we check the number of nodes in the friends list that are considered inactive. A node is considered
	inactive when the inactive counter reaches the inactive threshold. If more than 50 percent of the nodes in the friends list
	is inactive, the friend list is archived and considered as a group meeting that happened in the past. When this happens we
	clear the friends and strangers list and restart the algorithm.
\end{itemize}

In the end this algorithm creates a list of local detected group meetings. This list is used by the local group combination process to
detect instances of the same group with multiple encounters along the time.

\subsubsection{Local Group Combination}

In this step each mobile device process groups discovered in the previous step to discover groups that
have multiple encounters along the time. The algorithm is based on a metric called \textit{Group Correlation Coefficient} defined in [add-reference]. This metric basically computes the proportion of nodes shared between two sets.

Each node keeps a list of \textit{combined groups}, that keeps track of groups with multiple encounters along the time. For each
local group detected in the previous process, we check if there is a combined group with Group Correlation Coefficient greater or equals 0.5.
If there is, the local group is combined into the combined group adding its members to it and registering a new encounter. If there isn't, a new combined group is initialized with the local group data.

The combined groups generated in this process are used by neighborhood inspection to compose the final groups considered in the forwarding algorithm.

\subsection{Neighborhood Inspection}

Besides inspecting its current neighborhood, at each considered time interval each node also collects its neighbors combined groups. The collected groups are combined with the groups generated by the local group combination process using the same approach described previously. Groups that have correlation coefficient greater of equals 0.5 are merged. This step is used to expand a node local vision with its neighbor
network knowledge. So, in the end the local combined groups are updated with neighbors detected group information.

\subsubsection{Group Graph Creation}

In this step we build the graph of groups using the combined groups created by the neighborhood inspection process. The graph is created using the approach described in \cite{groupMobility}

\subsection{Forwaring Decision}
\label{subsec:forwardingDistGroupsNET}

\section{Experiments}
\label{sec:GNExperiments}

\section{Results}
\label{sec:GNResults}

\section{Conclusion}
\label{sec:GNConclusion}


\section{The Distributed Groups NET}



\subsection{Mobile Group Detection}



