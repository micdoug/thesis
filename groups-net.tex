\chapter{Groups NET Distributed Implementation}
\label{ch:GroupsNet}

In D2D networks communication is established when a contact occurs, and the contacts are driven by human mobility. Therefore understanding human mobility and how people interact is a fundamental requirement to create suitable routing algorithms. Recent works have shown that the best routing solutions for D2D communication are those based on social context, mainly those that explore how people interact in groups or communities. In this chapter we propose a distributed implementation of Groups-NET, a forwarding algorithm based on group encounters \citep{nunes2016leveraging}. We propose an algorithm for group detection and tracking in a distributed environment and used it to implement Groups-NET. Through experiments with a real mobility trace containing 115 nodes we show that the solution achieves a good delivery ratio with an expressive lower network overhead when compared with the state-of-art BubbleRap algorithm.

<Write down the chapter structure when finished>
% This chapter is organized as follows. The section \ref{sec:groupsNet} details the original Groups NET implementation as is proposed in \cite{nunes2016leveraging}.
% The section \ref{sec:distributedGroupsNET} details the proposed distributed implementation inspired by the original Groups NET. This sectio is divided in two parts: in
% \ref{subsec:subsec:groupDetection} the grouping detection algorithm is detailed and in \ref{subsec:forwardingDistGroupsNET} the forwarding decision is also detailed.
% In section \ref{sec:GNExperiments}

\section{The Groups NET Algorithm}
\label{sec:groupsNet}

Groups-NET is a multi hop and multi copy forwarding algorithm for D2D networks that explores people group meetings to propagate content. A group is defined as a set of people that are placed near each other in a given point of a time due to a common goal. For example, people working in the same company or students attending the same class. The algorithm is based on the idea that group encounters show some regularity along the time, because in general people have regular schedules and routines. Therefore we can explore group encounters to forward messages. In their previous work, \citet{groupMobility} proposed an algorithm for group detection and tracking, in which detected groups show encounters regularity along the time, mainly on daily and weekly basis.

This algorithm operates on contact traces and work as follows. First, the contact trace is split considering time windows of a predefined size. Contacts in each time window are used to create contact graphs, in which vertices denotes devices and edges denotes contacts in that time window. After this a sequence of graph contacts along the time is created, representing people contacts along the time. For each of these graphs the clustering algorithm Clique Percolation \citep{derenyi2005clique} is executed, to find clusters based on the contacts of that time interval. A cluster in a contact graph represents a group encounter in a that time interval. In order to find groups that have encounters in different time windows the authors introduced the \textit{Group Correlation Coefficient} metric, which measures the similarity of two group captured in distinct contact graphs returning a value. This metric is defined as the number of intersection members of the two groups divided by the number of members of the union of the groups, therefore returning a value between 0 and 1. Groups detected in distinct time windows with \textit{Group Correlation Coefficient} greater or equals $0.5$ are considered as the same group with multiple encounters.

Groups-NET forwards messages using the most probable group-to-group route. To compute this route, a graph is created in which groups are the vertices and there is an edge between each possible pair of groups. The edges are weighted considering the group correlation coefficient between the two groups and the probability of each group of encountering in the near future. The group correlation coefficient is expressed in equation \ref{eq:groupCorrelationCoefficient}. The probability of a group encountering is defined in equation \ref{eq:encounterProbability}, in which $TTL$ represents the time before a message is expired (we are interested in the probability of a group encountering before a given message has TTL expired) and $N$ represents the number of times a group has met considering the last $T$ hours. Based on these two values the edge weight is computed according to equation \ref{eq:edgeWeight}.

\begin{equation}
	\label{eq:groupCorrelationCoefficient}
	GC_{G_1G_2} = \frac{(G_1 \cap G_2)}{(G_1 \cup G_2)}
\end{equation}

\begin{equation}
	\label{eq:encounterProbability}
    P_G = 1 - e^{(-\frac{TTL * N}{T})}
\end{equation}

\begin{equation}
	\label{eq:edgeWeight}
    E_{G_1G_2} = -\log(GC_{G_1G_2} * P_{G1} * P_{G2})
\end{equation}

With the group graph built it is possible to define the route to forward a message. Given a message with defined source and destination nodes, we compute shortest paths for each pair of groups $(G_s \rightarrow G_d)$, in which $G_s$ is a group that the source is present and $G_d$ is a group that the destination node is present. From this list of paths the shortest one is chosen as the most probable group-to-group path. The message if forwarded upon a contact if the other node is present in one of the groups of the chosen path.

Thought experiments, the authors show that Groups-NET outperforms Bubble-Rap in terms of network overhead. However, this solution relies on the global network knowledge to detect and track groups, which is unfeasible in real scenarios. But the authors discussed that creating a distributed algorithm for detecting and tracking groups should be possible using a the history of contacts of the node. With this solution in place, the remaining definitions for forwarding messages used by Groups-NET can be applied without modifications. In the following section we present a solution to tackle this problem.

\section{Distributed Groups NET}
\label{sec:distributedGroupsNET}

In this section we propose a distributed implementation of Groups-NET forwarding algorithm. We define a group detection algorithm in which nodes use neighborhood discovery to infer social group meetings. This detection algorithm is then combined with the original forwarding decision mechanism defined by \citet{nunes2016leveraging} to build the distributed version of Groups-NET.

\subsection{Grouping Detection and Tracking}
\label{subsec:groupDetection}

The mobile group detection algorithm proposed here is derived from the ideas presented in \cite{groupMobility}. A group is defined as a set of people that get in contact on a given point of space and time. The authors show that group encounters have some level of regularity along the time (mainly at daily and weekly basis). This property can be used by forwarding algorithms.

In the original proposal the authors use a approach to detect groups based on global network knowledge. They basically
build a contact graph considering a predefined time interval, and for each graph is used the Clique Percolation community
detection algorithm. Each community detected by the algorithm is considered a group meeting in that time window. Then
a metric called \textit{Group Correlation Coefficient} is used to detect instances of the same group across multiple time
windows.

With this approach the authors show that groups usually have regular encounters along the time (specially in daily and weekly basis).
But they also discuss that the detection approach is unfeasible for a distributed environment, because it assumes a global network
knowledge. However, authors also discuss that implementing a distributed solution for this should be a simple task, because in the local
scope nodes can use neighborhood discover strategies and process regular neighbors encounters to decide their group encounters.

In this work we expanded this idea to build a distributed solution for group detection.It is composed of four processes
that are executed concurrently by each node using basically neighborhood inspection and some basic additional parameters. In the following sections each process is explained.

\subsubsection{Device's Local Group Detection}

This process is responsible for processing nodes' local contacts and decide when a group meeting happens.
The algorithm is very simple. Each node keeps two lists of devices. The first is the \textit{friends} list (lets call it FL)
that keeps track of current nodes considered as friends, i.e, members of a group that have a recent encounter.
The second list is the \textit{strangers} list (lets call it SL), that keeps track of recent nodes' contacts that are not yet
considered as friends. Each entry in these lists have a contact counter that keeps track of consecutive
contacts with that node, and also have a inactive counter that keeps track of consecutive periods of time
without contact with that node.

The node inspects its neighborhood at each predefined \textit{time interval} and based on current neighbors
it updates the friends and strangers list. This update is based on two predefined parameters: the \textit{friend threshold}
and \textit{inactive threshold}. Lets call these parameters as FT and IT respectively. Based on these parameters the following
steps are executed:

\begin{itemize}
	\item At each time interval a node collects its current neighbors (lets call it CN).
	\item The first step is to update the counters of friends list. For each current neighbor that is present in the friends
	list, we increase the contact counter and reset the inactive counter. For each node present in the friends list that is
	not a current neighbor we reset the contact counter and increase the inactive counter.
	\item The second step is to update the strangers list. For each current neighbor that is present in the strangers list
	we reset the inactive counter and increase the contact counter. If the contact counter reaches the friend threshold
	the node is promoted to friends list. For each node that is present in strangers list but is not a current neighbor
	we reset the contact counter and increase the inactive counter. If the inactive counter reaches the inactive threshold
	the node is removed from the strangers list. Nodes that are current neighbors and are not present in both friends and strangers
	list are added in the strangers list with contact counter equals 1.
	\item As a final step, we check the number of nodes in the friends list that are considered inactive. A node is considered
	inactive when the inactive counter reaches the inactive threshold. If more than 50 percent of the nodes in the friends list
	is inactive, the friend list is archived and considered as a group meeting that happened in the past. When this happens we
	clear the friends and strangers list and restart the algorithm.
\end{itemize}

In the end this algorithm creates a list of local detected group meetings. This list is used by the local group combination process to
detect instances of the same group with multiple encounters along the time.

\subsubsection{Local Group Combination}

In this step each mobile device process groups discovered in the previous step to discover groups that
have multiple encounters along the time. The algorithm is based on a metric called \textit{Group Correlation Coefficient} defined in [add-reference]. This metric basically computes the proportion of nodes shared between two sets.

Each node keeps a list of \textit{combined groups}, that keeps track of groups with multiple encounters along the time. For each
local group detected in the previous process, we check if there is a combined group with Group Correlation Coefficient greater or equals 0.5.
If there is, the local group is combined into the combined group adding its members to it and registering a new encounter. If there isn't, a new combined group is initialized with the local group data.

The combined groups generated in this process are used by neighborhood inspection to compose the final groups considered in the forwarding algorithm.

\subsection{Neighborhood Inspection}

Besides inspecting its current neighborhood, at each considered time interval each node also collects its neighbors combined groups. The collected groups are combined with the groups generated by the local group combination process using the same approach described previously. Groups that have correlation coefficient greater of equals 0.5 are merged. This step is used to expand a node local vision with its neighbor
network knowledge. So, in the end the local combined groups are updated with neighbors detected group information.

\subsubsection{Group Graph Creation}

In this step we build the graph of groups using the combined groups created by the neighborhood inspection process. The graph is created using the approach described in \cite{groupMobility}

\subsection{Forwaring Decision}
\label{subsec:forwardingDistGroupsNET}

\section{Experiments}
\label{sec:GNExperiments}

\section{Results}
\label{sec:GNResults}

\section{Conclusion}
\label{sec:GNConclusion}


\section{The Distributed Groups NET}



\subsection{Mobile Group Detection}



